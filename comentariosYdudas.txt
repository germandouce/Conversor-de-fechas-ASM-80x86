#Trabajo práctico Nro 20
#Conversor de Fechas
#Desarrollar un programa en assembler Intel 80x86 que permita convertir fechas válidas con el 
# formato DD/MM/AAAA a formato romano y/o juliano (DDD/AA); también debe permitir su inversa.
#Ejemplo:
# - Formato Fecha (DD/MM/AAAA): 14/10/2020
# - Formato Romano: XIV / X / MMXX
# - Formato Juliano (DDD/AA): 288/20

______Contador de tiempo______________________________________________
+ 5hrs un dia hace un tiempo
+ 5hrs 15 min 23/10/2022 (estructura gral del prgrm)
_______________________________________________

QUE FALTA De + importante a - importante
0-> BUG EN VALIDAR FECHA GENERAL ACEPTA NUMEROS MUY GRANDES NO SE POR QUE

1)-> Comversor de Dia Jul A Gregoriano
2)-> crear rutina copiando lo q hay en validacion para convertir 
anio jul a anio Grego 
3)-> Validar fecha Romana a NIVEL LETRAS (SEA ALGUNA DEL VECTOR)
creo q no voy a valiar xq no se como que el numero en si sea valido
4)-> Hacer una rutina q comprenda el conversor de NUMEROS romano - grego y el viceversa
Y meter ahi los movs que hay q hacer para dia mes y anio
5)-> descomentar y chequear funcionamiento tieniendo los 4 conversores 
(ya con subrutinas hechas)
    -juliano a A Romano 
    -Romano a Juliana
    (los otros 4 deberian funcar)

7)-> modularizar en gral
8)-> sacar #
9)Testing..
______(Tp con minimos requisitos???) PREENTREGA?
ALCARANDO o no aclarando que no doy mucha libertad al usuario para elegir que
converitr y a q, y q no.
6)-> Cambiar "completamente" fujo del prgm para que se le pregunte al usuario
a q queire conevrtir, ver comentarios en main.





Buenas, quería aclarar un par de dudas que tenía sobre la consigna del TP 20.
-        ¿Se debería poder convertir fechas del formato Juliano al Romano y viceversa?

·         ¿Se deben considerar los años bisiestos a la hora de manejar el formato Juliano?

·         Noté que el formato Juliano solo maneja 2 cifras en vez de 4 a la hora de expresar el año. Esto causaría ambigüedad a la hora de convertir del formato Juliano al formato de fecha, ya que la expresión 1/17 podría corresponder al 1/1/1917  (O 1/1/1817, 1717, …, etc). ¿Cómo se debe proceder en este caso?

·         ¿Cuáles son las cotas numéricas, se debería ir hasta el año 0 y el año 9999?

Muchas gracias de antemano.


DUDAS:
0) tengo q adivinar q fecha ingresa o le puedo decir "che, en q fomrato vas a meter la fecha? 
y dsps a q queres convertir
puedo pedir la fecha como dd mm aaaa con ESPAcios al usuario o va con barras si o si?


1)Dado que el formato juliano solo usa 2 cifras para expresar el año esto podria 
generar ambiguedad al convertir de "juliano" a "Fecha" ya que por ejemplo
3/19 podria ser 3/1/1919 o 3/1/1919 3/1/1819 etc. Como trabajo esto?

2) ¿Cuales son las cotas de años? Debe aceptar del año 0 a 9999?

3) Puedo usar una formula matemática que encontre googleando para
pasar de formato "fecha" a "juliano" y viceversa que incluso
considera años bisiestos?
Si lo requieren, puedo enviarles el codigo en python de la misma.


Noté que el formato Juliano solo maneja 2 cifras en vez de 4 a la hora de expresar el año.
 Esto causaría ambigüedad a la hora de convertir del formato Juliano al formato de
  fecha, ya que la expresión 1/17 podría corresponder al 1/1/1917  (O 1/1/1817, 1717, …, etc). ¿Cómo se debe proceder en este caso?
3) Ambiguedad con fechas?? ¿Cuáles son las cotas numéricas, se debería ir hasta el año 0 y el año 9999?

rta: Podes definir vos, por lo general se considera >= 50 corresponde siglo XX (1900) 
mientras que <50 corresponde al siglo XXI (2000)

Entonces el rango de fechas es este?

1950 1960 1970... 2049


4) Puedo usar fomula para conversor de gregoriano a juliano??

sino...
4 bis) 2 listas una anio bisiesto otra no..? 
) una sola y sumo 1 a partir de dia 60 no funca xq 31 + 29 de feb = 60 pero tmbien 31 + 28 + 1 de marzo = 60

def is_leap_year(year):
    """ if year is a leap year return True
        else return False """
    if year % 100 == 0:
        return year % 400 == 0
    return year % 4 == 0

def doy(Y,M,D):
    """ given year, month, day return day of year
        Astronomical Algorithms, Jean Meeus, 2d ed, 1998, chap 7 """
    if is_leap_year(Y):
        K = 1
    else:
        K = 2
    N = int((275 * M) / 9.0) - K * int((M + 9) / 12.0) + D - 30
    return N

def ymd(Y,N):
    """ given year = Y and day of year = N, return year, month, day
        Astronomical Algorithms, Jean Meeus, 2d ed, 1998, chap 7 """    
    if is_leap_year(Y):
        K = 1
    else:
        K = 2
    M = int((9 * (K + N)) / 275.0 + 0.98)
    if N < 32:
        M = 1
    D = N - int((275 * M) / 9.0) + K * int((M + 9) / 12.0) + 30
    return Y, M, D



COMENTARIOS y pensamientos

Puedo pedir un caracter de validacion del tipo de fecha, 
g gregoriano



;Validar fechas en rangos esperados
;y tambien como corte de suma de simbolos
;             finLoop, "N"
;mov          byte[finNum], "S" ;pongo una S para dar el okey de q se ingreso bien
;call            validarFyC ;validamos. en esa rutina modificamos el valor de 'inputValido'
;cmp             word[FinNum], "N" ;N - no valido / S - valido
;je              ingresoDatos


; mov             byte[inputValido], "N"; Le coloco un no a la var. es como un false antes del ciclo
;        ;chequeo q haya casteado los 2 valores enteros ( por ej 3 E daria 1)
;        cmp             rax,2 ;
;        jl              invalido


;concatenar un simbolo a la vez en el loop
; en vez de 4 va 1
; mov eax, [fizz]
; mov [buffer], eax
; mov eax, [buzz]
; mov [buffer+4], eax